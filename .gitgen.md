---
output:
context:
  - ./package.json
  - ./README.md
  - ./gitgen.ts
  - ./src/providers/index.ts
  - ./src/learn/index.ts
---
# git gen - Generative Git CLI Tool

## Project Overview
git gen is a CLI tool that augments the standard git workflow with AI-powered code generation. It analyzes repository patterns, conventions, and architecture to generate new code that matches the existing codebase style. The tool integrates seamlessly with git's extension mechanism, allowing users to invoke it as `git gen` rather than a separate command.

The core workflow follows the git lifecycle: clone → learn → branch → generate → commit → push → merge. The `learn` command analyzes a repository and creates a `.gitgen.md` specification file. The `gen` command uses this spec along with repository context to generate feature code. The `merge` command intelligently combines work from multiple branches using AI analysis.

## Tech Stack
- **Runtime**: Node.js with ESM modules
- **Language**: TypeScript (strict mode, ES2022 target)
- **Build Tool**: TypeScript Compiler (tsc) with noEmit for type checking
- **Testing**: Vitest for unit/integration tests, Playwright for E2E tests
- **AI Integration**: Vercel AI SDK with multi-provider support (Anthropic, OpenAI, OpenRouter)
- **CLI**: Native Node.js with shebang (`#!/usr/bin/env npx tsx`)

## Architecture

### Main Entry Point (`./gitgen.ts`)
The primary CLI entry point that handles command parsing and orchestration. Implements commands: `learn`, `gen`, `branch`, `merge`, `test`. Uses async/await patterns throughout with streaming AI responses. Parses flags like `-b/--branch`, `--dry-run`, `--prompt`, and provider configuration.

### Learn Module (`./src/learn/index.ts`)
Analyzes repository context by examining git history, file structure, and recent diffs. Generates the `.gitgen.md` specification file using AI. Includes post-processing to fix common YAML formatting issues in generated output.

### Providers Module (`./src/providers/index.ts`)
Multi-provider abstraction layer using Vercel AI SDK. Supports Anthropic (Claude), OpenAI, and OpenRouter. Provider selection via `GITGEN_PROVIDER` and `GITGEN_MODEL` environment variables. Falls back to detecting available API keys.

### Validation Module (`./src/validation/index.ts`)
Validates generated output, handles YAML parsing for file specifications, and ensures generated code matches expected patterns.

### Prompt Templates (`./prompts/*.md`)
External markdown files containing prompt templates for each command:
- `learn.md` - Repository analysis prompt
- `generate.md` - Feature generation prompt
- `branch-plan.md` - Branch planning prompt
- `branch-file.md` - Individual file generation prompt
- `merge.md` - Branch merge strategy prompt
- `init.md` - Initial setup prompt

## Coding Conventions

### File Organization
- `src/` - Source code modules organized by feature
- `tests/` - Test files mirroring source structure
  - `tests/unit/` - Unit tests
  - `tests/integration/` - Integration tests
  - `tests/e2e/` - End-to-end tests with Playwright
- `prompts/` - External prompt template files (markdown)
- `examples/` - Example projects and documentation
- `.github/workflows/` - GitHub Actions CI/CD workflows

### Naming
- Functions: camelCase (e.g., `generateFeature`, `parseConfig`, `getProvider`)
- Types/Interfaces: PascalCase (e.g., `ProviderConfig`, `GenerateOptions`, `FileSpec`)
- Files: kebab-case.ts (e.g., `index.ts`, `providers.test.ts`, `cli.test.ts`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_FILE_SIZE`, `DEFAULT_MODEL`)
- Environment variables: UPPER_SNAKE_CASE with prefix (e.g., `GITGEN_PROVIDER`, `ANTHROPIC_API_KEY`)

### Code Style
- 2-space indentation
- ES2022+ syntax (top-level await, optional chaining, nullish coalescing)
- Async/await over raw promises
- Template literals for string interpolation
- Destructuring for function parameters and imports
- Single quotes for strings (based on TypeScript defaults)
- No semicolons at line ends (inferred from diffs)
- Lines under 120 characters
- Imports organized: node builtins → external packages → local modules

### Error Handling
- Try/catch blocks around async operations
- Descriptive error messages with context
- Graceful fallbacks for missing configuration
- Process exit codes for CLI errors

### Commit Style
- Conventional commits format: `type: description`
- Types: `feat`, `fix`, `docs`, `chore`, `refactor`, `test`
- Lowercase descriptions, no period at end
- Co-authored-by trailer for AI-assisted commits
- Examples from history:
  - `feat: Add git gen test command with E2E testing and screenshots`
  - `refactor: Improve all prompt templates for better LLM output quality`
  - `fix: Improve learn command prompt and extract to external file`
  - `docs: readme`

## Adding New Features

Guidelines for adding new code that matches project patterns:

1. **Study the command pattern** - Each command follows a consistent structure: parse args, gather context, call AI provider, process response, write output. See existing commands in `gitgen.ts`.

2. **Extract prompts to external files** - Complex prompts belong in `prompts/*.md` files, loaded at runtime. Keep inline prompts minimal.

3. **Use the provider abstraction** - Never call AI APIs directly. Use `src/providers/index.ts` to support all configured providers.

4. **Add corresponding tests** - Unit tests in `tests/unit/`, integration tests in `tests/integration/`, E2E tests in `tests/e2e/`.

5. **Update documentation** - Add new commands to the README.md command table and include usage examples.

6. **Follow the streaming pattern** - Use streaming responses for long-running AI operations to provide user feedback.

### Example: Adding a New Command

```typescript
// In gitgen.ts - add new command handler

async function handleNewCommand(
  args: string[],
  options: { dryRun?: boolean; prompt?: string }
): Promise<void> {
  // 1. Parse command-specific arguments
  const targetPath = args[0] || '.'
  
  // 2. Gather repository context
  const repoContext = await getRepoContext()
  const spec = await loadGitgenSpec()
  
  // 3. Load prompt template
  const promptTemplate = await fs.readFile(
    new URL('./prompts/new-command.md', import.meta.url),
    'utf-8'
  )
  
  // 4. Build the full prompt
  const prompt = promptTemplate
    .replace('{{CONTEXT}}', repoContext)
    .replace('{{SPEC}}', spec)
    .replace('{{CUSTOM}}', options.prompt || '')
  
  // 5. Call AI provider with streaming
  const provider = getProvider()
  const stream = await provider.stream(prompt)
  
  // 6. Process and output results
  for await (const chunk of stream) {
    process.stdout.write(chunk)
  }
  
  // 7. Handle dry-run mode
  if (options.dryRun) {
    console.log('\n[dry-run] No changes written')
    return
  }
  
  // 8. Write output files
  await writeGeneratedFiles(result)
}
```

### Example: Adding a New Provider

```typescript
// In src/providers/index.ts

import { createAnthropic } from '@ai-sdk/anthropic'
import { createOpenAI } from '@ai-sdk/openai'

export function getProvider(): LanguageModel {
  const providerName = process.env.GITGEN_PROVIDER || detectProvider()
  const modelName = process.env.GITGEN_MODEL
  
  switch (providerName) {
    case 'anthropic':
      return createAnthropic({ apiKey: process.env.ANTHROPIC_API_KEY })
        .chat(modelName || 'claude-sonnet-4-20250514')
    
    case 'openai':
      return createOpenAI({ apiKey: process.env.OPENAI_API_KEY })
        .chat(modelName || 'gpt-4o')
    
    // Add new provider here following the pattern
    case 'newprovider':
      return createNewProvider({ apiKey: process.env.NEWPROVIDER_API_KEY })
        .chat(modelName || 'default-model')
    
    default:
      throw new Error(`Unknown provider: ${providerName}`)
  }
}
```

### Example: Adding a Test

```typescript
// In tests/unit/new-feature.test.ts

import { describe, it, expect, vi } from 'vitest'
import { newFeatureFunction } from '../../src/new-feature'

describe('newFeatureFunction', () => {
  it('should handle basic input', async () => {
    const result = await newFeatureFunction('test input')
    
    expect(result).toBeDefined()
    expect(result.status).toBe('success')
  })
  
  it('should throw on invalid input', async () => {
    await expect(newFeatureFunction('')).rejects.toThrow('Invalid input')
  })
})
```